–í—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–ª–æ–≤–∞—Ä—å –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ç–æ–º, –≤ –∫–∞–∫—É—é –ª–æ–∫–∞—Ü–∏—é –≤–µ–¥—É—Ç –∫–∞–∫–∏–µ –¥–≤–µ—Ä–∏. –ö–ª—é—á–æ–º —Å–ª–æ–≤–∞—Ä—è –±—É–¥–µ—Ç –∏–Ω–¥–µ–∫—Å –¥–≤–µ—Ä–∏, –∞ –∑–Ω–∞—á–µ–Ω–∏–µ–º - –ø–∞—Ä–∞ –∏–Ω–¥–µ–∫—Å–æ–≤ –ª–æ–∫–∞—Ü–∏–π, –∫–æ—Ç–æ—Ä—ã–µ —ç—Ç–∞ –¥–≤–µ—Ä—å —Å–≤—è–∑—ã–≤–∞–µ—Ç. –í–æ—Ç –ø—Ä–∏–º–µ—Ä —Ç–∞–∫–æ–≥–æ —Å–ª–æ–≤–∞—Ä—è:

C#

public Dictionary<int, (int, int)> DoorToLocations;
AI-generated code. Review and use carefully. More info on FAQ.
–ó–∞—Ç–µ–º –≤—ã –º–æ–∂–µ—Ç–µ –∑–∞–ø–æ–ª–Ω–∏—Ç—å —ç—Ç–æ—Ç —Å–ª–æ–≤–∞—Ä—å —Å–ª–µ–¥—É—é—â–∏–º –æ–±—Ä–∞–∑–æ–º:

C#

DoorToLocations = new Dictionary<int, (int, int)>
{
    { 1, (0, 1) }, // –î–≤–µ—Ä—å 1 —Å–≤—è–∑—ã–≤–∞–µ—Ç –ª–æ–∫–∞—Ü–∏–∏ 0 –∏ 1
    { 2, (1, 2) }, // –î–≤–µ—Ä—å 2 —Å–≤—è–∑—ã–≤–∞–µ—Ç –ª–æ–∫–∞—Ü–∏–∏ 1 –∏ 2
    // –∏ —Ç–∞–∫ –¥–∞–ª–µ–µ...
};
AI-generated code. Review and use carefully. More info on FAQ.
–¢–µ–ø–µ—Ä—å, –∑–Ω–∞—è –∏–Ω–¥–µ–∫—Å –¥–≤–µ—Ä–∏, –≤—ã –º–æ–∂–µ—Ç–µ –ª–µ–≥–∫–æ —É–∑–Ω–∞—Ç—å, –∫–∞–∫–∏–µ –ª–æ–∫–∞—Ü–∏–∏ –æ–Ω–∞ —Å–≤—è–∑—ã–≤–∞–µ—Ç. –ï—Å–ª–∏ —É –≤–∞—Å –≤–æ–∑–Ω–∏–∫–Ω—É—Ç –ø—Ä–æ–±–ª–µ–º—ã –∏–ª–∏ –≤–æ–ø—Ä–æ—Å—ã, –Ω–µ —Å—Ç–µ—Å–Ω—è–π—Ç–µ—Å—å –∑–∞–¥–∞–≤–∞—Ç—å –∏—Ö. –£–¥–∞—á–∏ –≤–∞–º –≤ –≤–∞—à–µ–º –ø—Ä–æ–µ–∫—Ç–µ! üòä user‚Äô private List<Vector3> SelectPlatformCoordinatesForDoors(List<Vector3> coordinates, int doorCount) {

        // –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –¥–ª—è –¥–≤–µ—Ä–µ–π
        var doorCoordinates = coordinates.OrderBy(x => UnityEngine.Random.value).Take(doorCount).ToList();
        for (int i = 0; i < doorCoordinates.Count; i++)
        {
            doorCoordinates[i] = new Vector3(doorCoordinates[i].x, doorCoordinates[i].y + 1, doorCoordinates[i].z);
        }

        return doorCoordinates;
    }

—Å–¥–µ–ª–∞–π –∞–Ω–∞–ª–æ–≥–∏—á–Ω—ã–π –º–µ—Ç–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç –≤—ã–¥–∞–≤–∞—Ç—å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—É –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã, –Ω–∞–¥ –∫–æ—Ç–æ—Ä–æ–π –±—É–¥–µ—Ç —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω —Å—É–Ω–¥—É–∫ assistant‚Äô –í—ã –º–æ–∂–µ—Ç–µ —Å–æ–∑–¥–∞—Ç—å –∞–Ω–∞–ª–æ–≥–∏—á–Ω—ã–π –º–µ—Ç–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—É –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã, –Ω–∞–¥ –∫–æ—Ç–æ—Ä–æ–π –±—É–¥–µ—Ç —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω —Å—É–Ω–¥—É–∫. –í–æ—Ç –∫–∞–∫ —ç—Ç–æ –º–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å:

C#

public Vector3 SelectPlatformCoordinateForChest(List<Vector3> coordinates)
{
    // –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—É—é –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—É –¥–ª—è —Å—É–Ω–¥—É–∫–∞
    var chestCoordinate = coordinates[UnityEngine.Random.Range(0, coordinates.Count)];

    // –ü–æ–¥–Ω–∏–º–∞–µ–º —Å—É–Ω–¥—É–∫ –Ω–∞ –æ–¥–Ω—É –µ–¥–∏–Ω–∏—Ü—É –≤—ã—à–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã
    chestCoordinate = new Vector3(chestCoordinate.x, chestCoordinate.y + 1, chestCoordinate.z);

    return chestCoordinate;
}
AI-generated code. Review and use carefully. More info on FAQ.
–¢–µ–ø–µ—Ä—å –º–µ—Ç–æ–¥ SelectPlatformCoordinateForChest –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—É –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã, –Ω–∞–¥ –∫–æ—Ç–æ—Ä–æ–π –±—É–¥–µ—Ç —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω —Å—É–Ω–¥—É–∫. –ï—Å–ª–∏ —É –≤–∞—Å –≤–æ–∑–Ω–∏–∫–Ω—É—Ç –ø—Ä–æ–±–ª–µ–º—ã –∏–ª–∏ –≤–æ–ø—Ä–æ—Å—ã, –Ω–µ —Å—Ç–µ—Å–Ω—è–π—Ç–µ—Å—å –∑–∞–¥–∞–≤–∞—Ç—å –∏—Ö. –£–¥–∞—á–∏ –≤–∞–º –≤ –≤–∞—à–µ–º –ø—Ä–æ–µ–∫—Ç–µ! üòä user‚Äô using System.Collections; using System.Collections.Generic; using UnityEngine; using System.Linq; using QuikGraph;

namespace Platformer2D.Generator { public class GeneratorGraph { private int countLocation; private int countStartVertix; public Dictionary<int, LocationType> Rooms; public Dictionary<int, List<int>> Transitions; public int ChestLocationIndex {get;private set;}

_locationNetwork = new GeneratorGraph(countLocation, countStartVertix);

—è —Ö–æ—á—É —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –æ–¥–Ω—É –ª–æ–∫–∞—Ü–∏—é –∏–∑ –≥—Ä–∞—Ñ–∞. –ú–Ω–µ –Ω—É–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –µ–µ –∏–Ω–¥–µ–∫—Å –∏ —Ç–∏–ø –≤ Start, –∞ –∑–∞—Ç–µ–º —Å–¥–µ–ª–∞—Ç—å —Ç–∞–∫, —á—Ç–æ–±—ã –ø—Ä–æ–∏–∑–æ—à–µ–ª —Å–ø–∞–≤–Ω –ª–æ–∫–∞—Ü–∏–∏: –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ –ª–æ–∫–∞—Ü–∏–∏ –≤ LocationType> Rooms; –¥–æ–ª–∂–µ–Ω –±—Ä–∞—Ç—å—Å—è –æ–¥–∏–Ω –∏–∑ –ø—Ä–µ—Ñ–∞–±–æ–≤ [SerializeField